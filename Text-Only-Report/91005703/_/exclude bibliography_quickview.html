
	
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>

<meta http-equiv="X-UA-Compatible" content="IE=7" />

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="author" content="Turnitin, LLC" />
    <meta name="keywords" content="" /> 
    <meta name="description" content="" />
<title>TurnitinUK</title>

<base href="http://www.turnitinuk.com">
<style type="text/css">
body	{
	color: #333;
	background: #C0C7CC;
	padding: 0;
	border: 0;
	font: 13px Verdana, arial, sans-serif;
	margin: 0;
	}
	
form	{
	padding: 0;
	margin: 0;
	}
	
body#display	{
	}
	
body#bodysource	{
	width: 520px;
	background: #F0F4FA;
	}
	
p	{
	padding: 10px 18px;
	margin: 0;
	}
	
img	{
	border: 0;
	padding: 0;
	}

div	{
	padding: 0;
	border: 0;
	}
	
iframe	{
	border: 0;
	margin: 0;
	padding: 0;
	}
	
strong	{
	font-weight: bold;
	}
	
ul	{
	padding: 0;
	margin: 0;
	list-style-type: none;
	font-size: 13px;
	}
	
ul li	{
	padding: 0;
	margin: 0;
	line-height: 16px;
	}
	
#index span#exclude	{
	margin: 0 50px 0 23px;
	}
	
#index a	{
	font-size: 11px;
	padding: 0 8px;
	}
	
#index select	{
	font-size: 12px;
	border: 1px solid #888;
	}
	
#index input.small	{
	margin: 0 0 0 5px;
	width: 30px;
	color: red;
	font-weight: bold;
	font-size: 13px;
	border: 1px solid #888;
	vertical-align: baseline;
	}
		
div.links	{
	width: 85%;
	margin: 0 auto;
	border-left: 1px solid #888;
	border-right: 1px solid #888;
	padding-top: 8px;
	background: #E8EEF7;
	text-align: left;
	}
	
.links div	{
	padding: 5px 13px 10px 20px;
	border-bottom: 1px dotted #888;
	}
	
.links div p	{
	padding: 2px 0 0 40px;
	}
	
div#body	{
	line-height: 17px;
	width: 85%;
	margin: auto;
	padding: 20px 0;
	background: #fff;
	border-bottom: 1px solid #888;
	border-right: 1px solid #888;
	border-left: 1px solid #888;
	text-align: left;
	}
	
#body p	{
	color: #000;
	padding-top: 10 0;
	margin: 0 40px;
	}
#actions {
	display: none;
	}

a.exclude	{
	float: right;
	margin: 0;
	padding: 0;
	}
/*= GENERAL 
=== === === === === === === === === === === === === === === === === === === === === === === === === === === === === === */	

body  #top_bar {
display: none !important;
}

body #index #exclude,
#download_button,
#print_button,
#index .right
 {
display: none;
}

body #index {
width: 85%;
margin-left: auto;
margin-right: auto;
border: 1px solid #999;
background: #ececec url(new_dynamic/images/22bd7a01a025b8de122259e42762f0a7cb_ug_toolbar_bg.gif) repeat-x center left;
}

#toolbar_wrapper {
padding-left:45px;
}

body #top {
width: 85%;
background-color: #FFF;
margin-left: auto;
margin-right: auto;
border: 1px solid #999;
border-bottom: none;
height: 210px;
}
body #content {
padding: 10px 60px;
}
body div#prefs {
display: none;
}

body #top h2 {
font-size: 20px;
font-weight: normal;
}

body #top h2 strong {
font-weight: normal;
}
body #top h2 em {
font-style: normal;
}


body #top h3 {
font-size: 16px;
font-weight: normal;
}

body #top h3 strong {
font-weight: normal;
}
body #top h3 em {
font-style: normal;
}

        
        body #top_body li	{/*Paper info li*/
            padding:0;
            margin: 0px 0px 2px 0px;
            font-size: 10px;
            }
            
            #top_body #print_wrapper {
                float:left;
                width: 50%;
            }
            
            #top_body .similarity_print_wrapper {
                width: 45%;
                min-width: 283px;
            }
                
            #top_body .similarity_box { /*Similiarity Box w/ Similarity by Source */
                float: right;
                border: solid 1px #666;
                margin-top: 60px;
                width: 350px;
            }
                #top_body .similarity_box .overall_similarity {
                    float: left;
                    border-right: solid 1px #666;
                }
                    #top_body .similarity_box .overall_similarity .color_box {
                        font-size: 14px;
                        width: 140px;
                    }
                        #top_body .color_box.green {
                            background-color: green;
                        }
                        #top_body .color_box.blue {
                            background-color: blue;
                        }
                        #top_body .color_box.yellow {
                            background-color: yellow;
                        }
                        #top_body .color_box.orange {
                            background-color: orange;
                        }
                        #top_body .color_box.red {
                            background-color: red;
                        }

                    #top_body .similarity_box .overall_similarity .similarity_title {
                        font-size: 13px;
                        font-weight: normal;
                        padding: 5px 0px 0px;
                        text-align: center;
                    }

                    #top_body .similarity_box .overall_similarity .similarity_percent {
                        font-size: 25px;
                        font-family: georgia, times, serif;
                        padding: 5px 0px 15px;
                        text-align: center;
                    }

                    #top_body .similarity_box .overall_similarity a {
                         display: none;
                    }

                #top_body .similarity_box .similarity_by_source {
                     float: right;
                     font-size: 10px;
                }
                    #top_body .similarity_box .similarity_by_source .similarity_title {
                         padding: 6px 0px 0px 10px;
                         font-weight: bold;
                         text-align: left;
                    }
                    #top_body .similarity_box .similarity_by_source dl {
                        padding-left: 10px;
                        margin: 14px 7px 0px 0px;
                    }
                    #top_body .similarity_box .similarity_by_source dt {
                         float: left;
                         width: 160px;
                    }
                    #top_body .similarity_box .similarity_by_source dd {
                        float: left;
                        margin: 0px;
                    }

	
		
#index span#exclude	{
	margin: 0 50px 0 23px;
	}
	
#index a	{
	font-size: 11px;
	padding: 0 8px;
	}
	
#index select	{
	font-size: 12px;
	border: 1px solid #888;
	}
	
#index input.small	{
	margin: 0 0 0 5px;
	width: 30px;
	color: red;
	font-weight: bold;
	font-size: 13px;
	border: 1px solid #888;
	vertical-align: baseline;
	}
		
div.links	{
	width: 85%;
	margin: 0 auto;
	border-left: 1px solid #888;
	border-right: 1px solid #888;
	padding-top: 8px;
	background: #E8EEF7;
	text-align: left;
	}
	
.links div	{
	padding: 5px 13px 10px 20px;
	border-bottom: 1px dotted #888;
	}
	
.links div p	{
	padding: 2px 0 0 40px;
	}
	
div#body	{
	line-height: 17px;
	width: 85%;
	margin: auto;
	padding: 20px 0;
	background: #fff;
	border-bottom: 1px solid #888;
	border-right: 1px solid #888;
	border-left: 1px solid #888;
	text-align: left;
	}
	
#body p	{
	color: #000;
	padding-top: 10 0;
	margin: 0 40px;
	}
#actions {
	display: none;
	}

a.exclude	{
	float: right;
	margin: 0;
	padding: 0;
	}
	
#small_matches_prefs {
    display:none;
}
/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
.yui-button{display:-moz-inline-box;display:inline-block;vertical-align:text-bottom;}.yui-button .first-child{display:block;*display:inline-block;}.yui-button button,.yui-button a{display:block;*display:inline-block;border:none;margin:0;}.yui-button button{background-color:transparent;*overflow:visible;cursor:pointer;}.yui-button a{text-decoration:none;}.yui-skin-sam .yui-button{border-width:1px 0;border-style:solid;border-color:#808080;background:url(../images/yui270/build/assets/skins/sam/96b257a32a932f7739d7dab52b38ee8fcb_sprite.png) repeat-x 0 0;margin:auto .25em;}.yui-skin-sam .yui-button .first-child{border-width:0 1px;border-style:solid;border-color:#808080;margin:0 -1px;_margin:0;}.yui-skin-sam .yui-button button,.yui-skin-sam .yui-button a{padding:0 10px;font-size:93%;line-height:2;*line-height:1.7;min-height:2em;*min-height:auto;color:#000;}.yui-skin-sam .yui-button a{*line-height:1.875;*padding-bottom:1px;}.yui-skin-sam .yui-split-button button,.yui-skin-sam .yui-menu-button button{padding-right:20px;background-position:right center;background-repeat:no-repeat;}.yui-skin-sam .yui-menu-button button{background-image:url(yui270/build/button/assets/skins/sam/6305efb37fa05af65c79b58b9d4c1b03cb_menu-button-arrow.png);}.yui-skin-sam .yui-split-button button{background-image:url(yui270/build/button/assets/skins/sam/ced974d5c685e5dfa0a37b824a6b5d48cb_split-button-arrow.png);}.yui-skin-sam .yui-button-focus{border-color:#7D98B8;background-position:0 -1300px;}.yui-skin-sam .yui-button-focus .first-child{border-color:#7D98B8;}.yui-skin-sam .yui-button-focus button,.yui-skin-sam .yui-button-focus a{color:#000;}.yui-skin-sam .yui-split-button-focus button{background-image:url(yui270/build/button/assets/skins/sam/36e66540d2feba76b8991e18b76fe93bcb_split-button-arrow-focus.png);}.yui-skin-sam .yui-button-hover{border-color:#7D98B8;background-position:0 -1300px;}.yui-skin-sam .yui-button-hover .first-child{border-color:#7D98B8;}.yui-skin-sam .yui-button-hover button,.yui-skin-sam .yui-button-hover a{color:#000;}.yui-skin-sam .yui-split-button-hover button{background-image:url(yui270/build/button/assets/skins/sam/36e66540d2feba76b8991e18b76fe93bcb_split-button-arrow-hover.png);}.yui-skin-sam .yui-button-active{border-color:#7D98B8;background-position:0 -1700px;}.yui-skin-sam .yui-button-active .first-child{border-color:#7D98B8;}.yui-skin-sam .yui-button-active button,.yui-skin-sam .yui-button-active a{color:#000;}.yui-skin-sam .yui-split-button-activeoption{border-color:#808080;background-position:0 0;}.yui-skin-sam .yui-split-button-activeoption .first-child{border-color:#808080;}.yui-skin-sam .yui-split-button-activeoption button{background-image:url(yui270/build/button/assets/skins/sam/890272b241c1d8a0db3ce5680b71fab0cb_split-button-arrow-active.png);}.yui-skin-sam .yui-radio-button-checked,.yui-skin-sam .yui-checkbox-button-checked{border-color:#304369;background-position:0 -1400px;}.yui-skin-sam .yui-radio-button-checked .first-child,.yui-skin-sam .yui-checkbox-button-checked .first-child{border-color:#304369;}.yui-skin-sam .yui-radio-button-checked button,.yui-skin-sam .yui-checkbox-button-checked button{color:#fff;}.yui-skin-sam .yui-button-disabled{border-color:#ccc;background-position:0 -1500px;}.yui-skin-sam .yui-button-disabled .first-child{border-color:#ccc;}.yui-skin-sam .yui-button-disabled button,.yui-skin-sam .yui-button-disabled a{color:#A6A6A6;cursor:default;}.yui-skin-sam .yui-menu-button-disabled button{background-image:url(yui270/build/button/assets/skins/sam/4df7235ca027f2546b2a216e59f81fb0cb_menu-button-arrow-disabled.png);}.yui-skin-sam .yui-split-button-disabled button{background-image:url(yui270/build/button/assets/skins/sam/db73dce6da2f5c5f02399c93488ce69ecb_split-button-arrow-disabled.png);}

</style>

</head>

<body onload="">

<link rel="stylesheet" type="text/css" href="/r/build/css/tii/88ee4ccd3555f2b759921fb5d58d83e5cb_container.css" media="all" />




<script type="text/javascript" src="/r/build/js/tii/8b608684a5f4aec1b540987c93498c01cb_tii_anonymous_marking.js"></script>




<script type="text/javascript">

function initAnonymousMarking () {
    // initialize panel.  
    var config = {
            zindex: 4,
            underlay: 'none',
            modal: true,
            visible: false,
            draggable: false,
            close: false,
            fixedcenter: true
    };
    if ($('disable_anonymous_marking')) {
        disableAnonymousMarkingPanel = new IP.widget.Panel($('disable_anonymous_marking'), config);
        if($D.hasClass('disable_anonymous_marking', 'app')) {
            disableAnonymousMarkingPanel.center = function () {
                var nViewportOffset = 20,
                    elementWidth = this.element.offsetWidth,
                    elementHeight = this.element.offsetHeight,
                    viewPortWidth = $D.getViewportWidth(),
                    viewPortHeight = $D.getViewportHeight(),
                    x,
                    y;

                if (elementWidth < viewPortWidth) {
                    x = (viewPortWidth / 2) - (elementWidth / 2) + $D.getDocumentScrollLeft();
                } else {
                    x = nViewportOffset + $D.getDocumentScrollLeft();
                }

				if (browser == 'Internet Explorer') {
					x = 0;
				}
                y = 2 + $D.getDocumentScrollTop();

                this.cfg.setProperty("xy", [parseInt(x, 10), parseInt(y, 10)]);
                this.cfg.refireEvent("iframe");
            };
        }
        disableAnonymousMarkingPanel.render(document.body);
        disableAnonymousMarkingPanel.hideEvent.subscribe(function () { $('anonymous_error').innerHTML = ''; }, false);
        disableAnonymousMarkingPanel.hide();
        Element.show($('disable_anonymous_marking'));
    }
}

function disableAM (data) {
    $('anonymous_title').innerHTML = data.title;
    document.disable_anonymous_marking_form.objectid.value = data.oid;
    disableAnonymousMarkingPanel.show();
}

function checkDisableAM () {
    var form = document.disable_anonymous_marking_form;
    if (form.reason.value.length <= 5) {
        $('anonymous_error').innerHTML = "请提供关闭匿名批注的原因。";
    }
    else {
        form.submit();
    }
    return;
}

YAHOO.util.Event.onDOMReady(initAnonymousMarking);

</script>

<div id="disable_anonymous_marking" class="app" style="display: none;">
<div class="anonymous_frames">
<form method="post" name="disable_anonymous_marking_form">
    <input type="hidden" name="objectid" value=""/>
    <input type="hidden" name="disable_anonymous_marking" value="1"/> 
    <div class="anonymous_header">
    	<h1>关闭匿名标记</h1>
		<p>请说明关闭匿名标记的原因： <span id="anonymous_title"></span><br />
			<strong>警告: 管理员可以存取此资讯。此设定是永久性的。</strong>
        
            </p>
        
    </div>
    <div class="anonymous_body">
        <textarea name="reason" cols="30" rows="3"></textarea>
        <p id="anonymous_error"></p>
    </div>
    <div class="anonymous_footer">
		<div class="anonymous_footer_buttons">
    		<span class="submit_form_button"><input type="button" onClick="checkDisableAM();" value="提交"></span><br>
        	<span class="submit_form_button"><input type="button" value="取消" onClick="disableAnonymousMarkingPanel.hide();"></span>
		</div>
    </div>
</form>
</div>
</div>
<div id="actions">
<p>这是您报告的印表版的检视。请点击 "打印" 以继续或 "结束" 以关闭视窗。</p>
<script type="text/javascript" language="javascript">
	var browserName=navigator.appName;
	var browserVer=parseInt(navigator.appVersion);
	if ((navigator.appVersion.indexOf("Mac")!=-1) && (browserName == "Microsoft Internet Explorer")) {
		document.write('<span class="AR10">键入 COMMAND-P 开始打印。</span><br><br>');
	} else {
		document.write('<a href="javascript:window.print();">打印</a>&nbsp;&nbsp;');
	}
</script>
<a href="javascript:window.close();">完成</a>
</div>


<!-- ########################### Preferences pop-up ##########################--> 
<div id="prefs" style="visibility:hidden">
<div class="padding">
<form name="prefs_form" method="post" accept-charset="utf-8">
<script type="text/javascript" language="javascript">
function savePrefs(){
	if (document.prefs_form.changed.value == 1){
		document.prefs_form.submit();
	}else{
        hidePrefsPane();
	}
}

function showPrefsPane(){
	document.getElementById('prefs').style.visibility='visible';
}

function hidePrefsPane(){
    document.getElementById('prefs').style.visibility='hidden';
}


var overlay;
function showSmallMatchExclusions() {
    var linkRegion = $D.getRegion('exclude_small_matches_link');
    var panelRegion = $D.getRegion('small_matches_prefs');
    var indexRegion = $D.getRegion('index');
    
    var topLocation = indexRegion.bottom;
    $D.setStyle('small_matches_prefs', 'top', topLocation + 'px');
    $D.setStyle('small_matches_prefs', 'left', linkRegion.left + 'px');
    
    $D.setStyle('small_matches_prefs', 'visibility', 'visible');

    // focus the field
    $D.hasClass('exclude_by_percent_row', 'selected') ? $('exclude_by_percent_value').focus() : $('exclude_by_words_value').focus();
}

function hideSmallMatchExclusions() {
    $D.setStyle('small_matches_prefs', 'visibility', 'hidden');
}

function selectSmallExclusionMethod(enableType) {
    if(enableType == 'words') {
        $('exclude_by_words_value').focus();
        
        $D.addClass('exclude_by_words_row', 'selected');
        $D.removeClass('exclude_by_percent_row', 'selected');
        $D.removeClass('exclude_by_words_row', 'disabled');
        $D.addClass('exclude_by_percent_row', 'disabled');
    }
    else {
        $('exclude_by_percent_value').focus();
        
        $D.removeClass('exclude_by_words_row', 'selected');
        $D.addClass('exclude_by_percent_row', 'selected');
        $D.addClass('exclude_by_words_row', 'disabled');
        $D.removeClass('exclude_by_percent_row', 'disabled');
    }
}

function updateExcludePercentage(wordCount) {
    var percent = Math.floor(wordCount / 2935 * 100);
    
    $('exclude_by_percent_value').value = percent;
}

function updateExcludeWordCount(percent) {
    var wordCount = Math.floor((percent/100) * 2935);
    
    $('exclude_by_words_value').value = wordCount;
}

function submitSmallMatchesChange() {
    var excludeBy = $D.hasClass('exclude_by_percent_row', 'selected') ? 'percent' : 'words';
    var excludeValue = excludeBy == 'percent' ? $('exclude_by_percent_value').value : $('exclude_by_words_value').value;
    
    changeSmallMatchExclusion(excludeBy, parseInt(excludeValue), 2935);
}

</script>
</script>
<input type="hidden" name="changed" value="0">
        <div class="pref_rows">
                <label>颜色代码匹配：</label>
                <select name="use_colors" onchange="document.prefs_form.changed.value=1">
                    <option value="1">是
                    <option value="0">否 
                </select>
                <div class="clear"></div>
        </div>
        <div class="pref_rows">
                <label>预设模式：</label>
                <select name="def_report_mode" onchange="document.prefs_form.changed.value=1">
                    <option value="0">显示所有匹配度最高的
                    <option value="1">每次显示一个匹配的
                    <option value="2">快速查看报告（经典页面）
                </select>
                <div class="clear"></div>
        </div>
        <div class="pref_rows">
                <label>自动导航</label>
                <select name="report_scrolling" onchange="document.prefs_form.changed.value=1">
                    <option value="0">跳到下一个符合处
                    <option value="1">移动到下一个谋和处
                </select>
                <div class="clear"></div>
        </div>
        
        <div id="prefs_confirm">
            <button onClick="savePrefs()" >储存</button>  
         <a href="javascript:void(0);" onClick="hidePrefsPane();">取消</a>
        </div>
</form>
</div>
</div>
<!-- ########################### END Preferences pop-up  ##########################--> 

<!-- ########################### BEGIN small matches pop-up  ##########################--> 
<div id="small_matches_prefs">
    <form onsubmit="submitSmallMatchesChange(); return false;">
        <ul>
            <li id="exclude_by_words_row" class="selected">
                <label for="exclude_by_words_value">字数: </label>
                <input type="text" id="exclude_by_words_value" size="3" value="" onkeyup="updateExcludePercentage(this.value)" onfocus="selectSmallExclusionMethod('words')"> 字
            </li>
            <li id="exclude_by_percent_row" class="disabled">
                <label for="exclude_by_percent_value">百分比: </label>
                <input type="text" id="exclude_by_percent_value" size="3" value="" max-length="3" onkeyup="updateExcludeWordCount(this.value)" onfocus="selectSmallExclusionMethod('percent')"> %
            </li>
        </ul>
        <p><input type='submit' value="提交"> 或 <a href="javascript:hideSmallMatchExclusions()">取消</a></p>
    </form>
</div>

<!-- ########################### END small matches pop-up  ##########################-->

<!-- ########################### Top of Report  ##########################--> 
<div id="top">
    <div id="content">
    
        <!-- ######### Top Bar  ##########################--> 
        <div id="top_bar">
                <ul id="top_bar_list1">
                      <!-- Preferences --><li><a href="javascript:showPrefsPane();">preferences</a></li> 
                </ul>
                <ul id="top_bar_list2">
                      
                </ul>
                <div class="clear"></div>
        </div>   
        <!-- ######### END Top Bar  ##########################--> 
        
        
        <!-- ######### Top Body  ##########################--> 
        <div id="top_body">
         
            <!-- Button to Turnitin2 -->
            <span id="link_to_tii2_or" class="yui-button yui-link-button goto-tii2" style="left:0">
                <span class="first-child">
                    
                    <a href='/newreport.asp?r=41.5378415389782&svr=301&lang=zh_hans&oid=91005703&sv=2'>文件检视工具</a>
                    
                </span>
            </span>

            <div id="print_wrapper">
                <div class="general_info">
                    <!-- Logo --> 
                    <h2>
                        <span class=""></span>
                        <strong>TurnitinUK</strong>
                        <em>原创性报告</em>
                     </h2>
                 
                     <!-- Paper Info -->               
                     <ul>
                         <li>已处理到: 29-6月-2018  7:34 上午 BST</li>
                         <li>代码: 91005703 </li>
                         <li>字数: 2935</li>
                         <li>已提交: 1</li>
                     </ul>
                </div>

                 <!-- Paper Title --> 
                <h3>
                    <strong>Ray Tracing Renderer: Reflection Technique for Game</strong> 
                    
                    <em>整合者 ChaPaper</em>
                    
                </h3>
            </div>
            
            <div id="similarity_print_wrapper">
                <div class="similarity_box">
                    <div class="overall_similarity">
                        <div class="color_box green">&nbsp;</div>
                        <div class="similarity_title">相似度指标</div>
                        <div class="similarity_percent">< 1%</div>
                    </div>
                    <div class="similarity_by_source">
                        <div class="similarity_title">依來源标示相似度</div>
                        <dl>
                            <dt>Internet&nbsp;Sources:</dt>
                            <dd>0%</dd>
                            <div class="clear"></div>
                            <dt>出版物:</dt>
                            <dd>0%</dd>
                            <div class="clear"></div>
                            <dt>学生文稿:</dt>
                            <dd>0%</dd>
                            <div class="clear"></div>
                        </dl>
                    </div>
                </div>
            </div>
            <div class="clear"></div>
                                 
        </div>
        <!-- ######### END Top Body  ##########################--> 
        
        
    </div>
</div>
<!-- ########################### END Top of Report  ##########################--> 



<!-- ########################### TOOLBAR  ##########################--> 
<div id="index">
	<div id="toolbar_wrapper">
                <span id="exclude">
                    <a href="javascript:changeQuoteExclusion(,)">排除引用</a>
                    <a href="javascript:changeBibliographyExclusion()">不含参考书目</a>
                    
                        <a href="javascript:showSmallMatchExclusions()" id="exclude_small_matches_link">不含小型相符结果</a>
                    
                    <img src="/r/build/images/buttons/small/03954abd4e4d9c247be91770fe32d3f1cb_arrow_blue_down.gif"  class="drop_down_image" />

                </span>
                
                <!-- Print,  Refresh, Download --> 
                <a id="download_button" title="下载" href="javascript:saveReport();">下载</a>           
                   
                <a title="打印" id="print_button" href="javascript:printReport();">打印</a>
                
                <div  class="right">
                <span>模式：</span> 
                <select id="action" onChange="changeMode(this.value, 'zh_hans')">
                    <option value="0">显示所有匹配度最高的
                    <option value="1">每次显示一个匹配的
                    <option value="2" selected>快速查看报告（经典页面）
                </select>
                </div>                
                  
                <div class="clear"></div>
	</div>
</div>
<!-- ########################### END TOOLBAR  ##########################--> 


<div class="links">
	<div>
	<p>< 1% match (从 2016年03月23日 的网络)</p>

	<p><a href="http://dc.ewu.edu/cgi/viewcontent.cgi?article=1093&context=theses" target="_blank" style="color:red">http://dc.ewu.edu/cgi/viewcontent.cgi?article=1093&context=theses</a></p>

	</div>
</div>
<div id="body">
<p>Ray Tracing Renderer: Reflection Technique for Game Anting Zhou ? Abstract—Game is become an important part of our life. Many graphics professors focus on providing a realistic virtual world. One of the focuses is reflection technology. This article will introduce different techniques for rendering the reflection and analyze their advantages and disadvantages. In those techniques, this article will introduce the ray tracing renderer in detail and generally design the classes which will be used in ray tracing renderer. The process design also is introduce in brief and describe how to perform basic ray tracing technique. Index Terms—Environment mapping, Ray Tracing, Reflection, Rendering Technique, Screen-Space Reflection I. INTRODUCTION R ENDERING technology is developed with game industry for many years. Developers are try their best to provide highly realistic or even surreal virtual environment. But still, there lots of technical challenges in this area, like the simulation of water or smoke, ambient occlusion and high quality reflection. Reflection phenomenon can be seen everywhere in real world but hard for computer simulation in real time. The contradiction of efficiency and accuracy confuses the developer all the time in this area. Screen-space reflection and environment mapping are two kinds of implementation generally used in modern games. Their both simplified the rendering progress by some techniques with the cost of providing a inaccurate result. And an other solution is ray tracing which simulate the refraction and reflection of the ray of light like the real world. It provides high accuracy of reflection image but increase the performance costs of graphic card. II. ENVIRONMENT MAPPING Environment mapping is a common method used in games because of its low difficult of implementation. In brief summary, environment mapping generates a cube map of environment based on a specific camera. Then the algorithm calculates the reflex direction rely on the incident direction and samples the environment map using reflex direction.[1] The Environment mapping performs acceptable reflection of static and far object with insignificant performance cost because the reflection map rendered only once and can be preprocessed. But for dynamic object, it is hard to perform environment mapping due to the high cost of generating environment map every frame. Also the environment mapping only provides the approximate result and the error become significant when the object is near the reflection surface. The error mainly comes from the difference of reflection position and camera position. As the Fig. 1. shown, the reflex light hits the spot A, but the algorithm samples the environment map by the reflex direction which is equivalent to the color information at spot B. Fig. 1. Error in Environment Mapping III. SCREEN-SPACE REFLECTION With the increasing requirement of graphics in games, some new techniques come up to provide better performance. SSR(Screen-Space Reflection) is one of the common used techniques. SSR is image-based algorithm which uses the information stored in G-buffer to calculate the reflection data. For each frame, the normal and position information based on screen space will be rendered into G-buffer. When performing reflection, all position like the position of light source will transform to same coordinate then calculate the reflex direction and sample the color buffer[2]. But because the SSR is using the information of G-buffer which is incomplete compared with the whole scene. In some situation, like the calculated reflex ray of light hits the back face of an object which is unseen in the screen space(shown as Fig. 2.), the algorithm will sample nothing and use an alternative solution such as perform blur in that area. Fig. 2. Disadvantage of SSR IV. RAY TRACING Ray tracing is a technology that calculates the colour of each pixel by tracing the path of their ray of light and simulating the interaction of virtual object and get the final image as output.[3] Because of following the physical rules of light transmission, ray tracing can get more accurate and more realistic image compared with environment mapping and screen-space reflection mentioned above. And it can also simulate almost all the optical phenomenons like refraction, reflection, scattering and dispersion. But it requires massive calculation which hard to be satisfied by personal computer even their performance improved a lot these years. Thus, ray tracing mainly was used in off-line rendering such as 3D animation or special effects in films. But due to requirement of real-time calculation in computer game area, the application of ray tracing is infrequent. Ray tracing algorithm is highly parallelized.[4] Tracing the ray of light for each pixel in image can execute in parallel because the calculation of each pixel not rely on the result of others. The calculation amount of ray tracing is direct proportional to the quantity of pixels in output image. Thus, the time-consumption can be reduced remarkably if the ray tracing algorithm can run totally in parallel. When apply parallel computing in particular, for example in rendering 3D film, hundreds of computers render the image in same time dividing by block generally. But for personal computer, because the CPU executes the instructions in series, it is hard to apply parallel computing physically. And if solving the problem by adding the cores in CPU, the cooperation between cores will become complex and restrict the software structure. Differ from CPU, GPU is designed for image-relevant calculation which provides brilliant parallel computing performance. Due to its logical control ability is relatively weak, the main job of GPU was rendering the vertex and fragment for a long time. But the situation is different these years, because of the development of graphic card. With the increasing demand of parallel computing in personal computer, graphic card manufacturer keep upgrading the technology. The concept of rendering streamline and GPGPU(General Purpose Graphic Process Unit) came up providing acceptable solution for apply parallel computing in personal computer. Also some computing language or describe language are provided by manufacturer for graphic engineers to reduce the difficulty of graphic development. All those changes make it possible to apply complex parallel computing, such as ray tracing, in personal computer and give it acceptable performance. V. DEMAND ANALYSIS A. Diffuse reflection The diffuse reflection happens on object surface when directional light lighting rough surface. The light will scatter off the surface making it possible to be seen in all directions. But the diffuse light not uniformly distributed in all directions. It has some certain rules, like Lambert’s cosine law, which reveal the correlation between brightness and included angle between surface normal and incident direction. Diffuse light is commonly seen in real world which needs appropriate implementation in renderer. B. Shadow When the light from the light source is blocked by opacity object, dark area will be left as shadow. The performance of the shadow is a important part in graphic rendering, which also is a hard part. The shadow in real world is complex because of the multiple light source and indirect illumination. So, how to provide a realistic and accurate shadow is a focus of graphics. This article will mainly focus on reflection and ray tracing technique itself. So this article only talks about the shadow produced directly block. C. Specular reflection The specular reflection occurs when the ray of light intersects with smooth surface. Specular reflection follows the Law of Reflection that incident angle equals to reflex angle, and they are coplanar to normal.[5] Thus, the specular light only can be observed in certain direction. The common representation of specular reflection is rendering the space. The position and vector in 3D space are described by combined image of object surface and reflected image based x, y, z components. When solving the space geometric on the smoothness of the surface. Specular reflection is problem, normalization, dot product, cross product are generally used in modern game in which ray tracing generally used. So it is important to implement those algorithm provides more realistic performance than method and override the add and minus operator. environment mapping and screen-space reflection. D. Refraction The light will be refracted when it intersects with the interface between two transparent materials with different refraction index. The refraction follow the Snell’s Law which describes the correlation between the included angles that between incident light, refraction light and normal interface normal. Compared with other kinds of renderer, ray tracing can easily implements complex refraction phenomenons like convex lens and concave lens imaging by simulating the propagation of light. E. Recursive ray tracing As introduced above, when the light hits the surface, it may generates two rays of light based on the refraction and reflection. A ray of shadow may also be generated depends on the transparency of the material it hits. The rays of Fig. 4. Vector3 Class refraction and reflection light may also hit the surface and generate more rays. Thus, the process of solving the ray tracing should be recursive to solving those rays which provides high degree of realism. 2) Ray Ray class represent a ray of light which include the origin VI. OUTLINE DESIGN and its direction normal. Those information are used for ray- A. Class designs object intersection to figure out the intersection point. The ray tracing renderer is designed as Fig. 3. based on the features of ray tracing algorithm. Fig. 5. Ray Class Fig. 3. Classes in Ray Tracing Renderer 1) Vector3 3) Camera Vector3 is a basic data structure in ray tracing renderer. Because this article is going to implement ray tracing a 3D Camera class is used to stored status of the camera, which render technique, all calculation of ray tracing is done in 3D represent the observer, include its position, pitch and yew which describe the observation angle and projection matrix which giving the information of near and far plane, field of Those configuration recorded by canvas, so that when vision and etc. For free observation, the camera class also output is changed, only canvas need to be modified. need implement move and rotate method. When preforming ray tracing, the original ray is build by connecting camera position and pixel in viewport. Fig. 7. Canvas Class 5) Scene Scene class stores the data of the scene to be rendered. Generally, there are two kinds of data stored in scene class: light source and primitive. Scene class provides some interfaces for renderer to access those data. When amount of light source and primitive are massive, it will causing the performance problem. To prevent this situation, scene manager is also needed to sort resources like sort opacity object by depth to make them fail the depth test. Fig. 6. Camera Class 4) Canvas Canvas class represent the output of the renderer. Color information of pixels may render to frame buffer or screen. Fig. 8. Scene Class 6) LightSource LightSource is an abstract class which represents all kinds of light source in scene and provides the pure virtual functions. Different light source inherited from LightSource class just need implement the virtual functions. For ray the renderer won’t generate relevant light to improve the tracing renderer, the light source should have two member performance. variables, light position for calculating shadow and direction <img src="/r/build/images/new_dynamic/df3e567d6f16d040326c7a0ea29a4f41cb_spacer.gif" height="1" width="1" alt="Begin Match to source 1 in source list: http://dc.ewu.edu/cgi/viewcontent.cgi?article=1093&context=theses"><a href="javascript:void(0);" onClick="window.open('newreport_context.asp?r=41.5378415389782&svr=301&lang=zh_hans&sid=259983300&n=2474&svr=306&session-id=60c83168f05a4821052b29b6f061fe41', 'context', 'location=no,menubar=no,resizable=yes,scrollbars=yes,titlebar=no,toolbar=no,status=no')" style="color:red" class="red">for calculating diffuse and specular light.</a><img src="/r/build/images/new_dynamic/df3e567d6f16d040326c7a0ea29a4f41cb_spacer.gif" alt="End Match"> In this article, <img src="/r/build/images/new_dynamic/df3e567d6f16d040326c7a0ea29a4f41cb_spacer.gif" height="1" width="1" alt="Begin Match to source 1 in source list: http://dc.ewu.edu/cgi/viewcontent.cgi?article=1093&context=theses"><a href="javascript:void(0);" onClick="window.open('newreport_context.asp?r=41.5378415389782&svr=301&lang=zh_hans&sid=259983300&n=2474&svr=306&session-id=60c83168f05a4821052b29b6f061fe41', 'context', 'location=no,menubar=no,resizable=yes,scrollbars=yes,titlebar=no,toolbar=no,status=no')" style="color:red" class="red">to</a><img src="/r/build/images/new_dynamic/df3e567d6f16d040326c7a0ea29a4f41cb_spacer.gif" alt="End Match"> simplify <img src="/r/build/images/new_dynamic/df3e567d6f16d040326c7a0ea29a4f41cb_spacer.gif" height="1" width="1" alt="Begin Match to source 1 in source list: http://dc.ewu.edu/cgi/viewcontent.cgi?article=1093&context=theses"><a href="javascript:void(0);" onClick="window.open('newreport_context.asp?r=41.5378415389782&svr=301&lang=zh_hans&sid=259983300&n=2474&svr=306&session-id=60c83168f05a4821052b29b6f061fe41', 'context', 'location=no,menubar=no,resizable=yes,scrollbars=yes,titlebar=no,toolbar=no,status=no')" style="color:red" class="red">the</a><img src="/r/build/images/new_dynamic/df3e567d6f16d040326c7a0ea29a4f41cb_spacer.gif" alt="End Match"> renderer, only point light and parallel light are implemented. Fig. 9. LightSource Class 7) Material Material class is used to modify the material of the primitive. Material class stores the important data of the material which can be used by shader. Also, it stores the diffuse reflection coefficient, specular reflection coefficient, refraction coefficient and refractive index. The first three Fig. 10. Material Class coefficient introduced above describe the energy distribution of diffuse reflection, specular reflection and refraction which add up to one. When recursively tracing 8) AABB the ray of light, the final output will add each light based on this coefficient as weight. And if the specular reflection AABB(Axis-Aligned Bounding Box) class represent the coefficient or refraction coefficient is zero which means axis-aligned cube, which completely encircles the primitive. specular reflection or refraction won’t occur on this surface, When performing intersection test, the ray of light will run intersection test with AABB first. If the ray not intersect with AABB, the intersection test will stop. Otherwise, the ray will do the test with primitive. Because the AABB is axis-aligned box, it is easy to perform intersection test. By doing this, renderer can greatly reduces the complexity of intersection test and provides a better performance. Fig. 11. AABB Class 9) Primitive Primitive class is an abstract class which is the base class of all renderable object. An object must inherit from primitive class and implement its pure virtual class to be rendered. The function in primitive class includes getting normal of a vertex in primitive, getting and setting the material of a primitive, getting the intersection point with given ray. The normal of the vertex is used to define the front and back of the primitive and calculate the reflection and refraction light. The intersection point is one of the most important parameter used by ray tracing renderer. Renderer will choose the closest intersection point and calculate the diffuse light and generate specular reflection and refraction ray of light. The primitive types used by this article are plane, sphere, cube and triangle Fig. 12. Primitive Class . 10) Renderer Renderer class is an abstract class which contains the pointers to scene, camera and canvas objects. This class provides the general interfaces such as render() function. The actual ray tracing renderer will implement this function which is used to generate the original ray of light based on the connection between the camera position and pixel in canvas. The original ray of light intersects with primitive in the scene and recursively generate more ray of light based on diffuse reflection coefficient, specular reflection coefficient and refraction coefficient recorded by material of the primitive. When the this generation reaches the maximum depth setting in the renderer, the color information of all lights will be added up based on the weight of each light carrying out the final output. The process will be done for each pixel in canvas generating the final image as ray tracing renderer’s output. Fig. 13. Renderer Class B. Process Design The RayTracingRenderer class is the most significant class in ray tracing algorithm introduced by this article. This class provides almost all method required by algorithm. Other class like scene, camera and canvas provide data abstraction and packaging. By using abstraction and inheritance, the ray tracing renderer introduced by this article significantly increasing its maintainability and extensibility. The RayTracingRenderer is performed as follow. First of all, the init() function of RayTracingRenderer will be executed for initialize the renderer. The initialization includes loading the data into the scene, setting the position and rotation of the camera, setting the size of the canvas and etc. The whole initialization will be divided into some small individual functions such as LoadScene() and InitRenderArea(). After initialization, RayTracingRenderer will generate the original ray of lights rely on resolution of canvas and position of camera. Each ray of light will be represented by the instance of Ray class. Then the RayTracingRenderer will traversal all AABB in the scene for now. World partitioning may be added in further work. For each light which intersects with AABB will progress the further intersection test with primitive. By doing this, all of the intersection points between origin lights and primitives will be worked out and stored in array. For each intersection point, RayTracingRenderer will traversal light source array and call the getDirection() method. Also the getNormal() method of Primitive class will be called to getting the normal information at intersection point. In same way, the material which contains the coefficients of reflection and refraction will be get by calling the getMaterial() method. Based on all information above, the diffuse color will be figured out using Phone lighting model[6] at each intersection point. After this, the diffuse color will multiple the coefficient of diffuse reflection as a part of final output. According to the material data at intersection point, the reflection and refraction ray may be generated. The direction information will be calculated based on the incident direction and normal at intersection point following the relevant laws. And the origin of generated ray is the intersection point. Each generated ray will recursively progress the same calculation as the original light figuring out the diffuse light and generating reflection and refraction light until reach maximum recursive depth. Then, the RayTracingRenderer will backtrack the recursion and add color of reflection and refraction ray of light based on its weight. When backtracking to the original light, the whole process is over, the RayTracingRenderer will record current color as final color. All original lights will perform the same calculation and call the setPixelColor() method provided by Canvas class. The canvas will figure out the final image after traversal all original light. Fig. 14. General Process VII. CONCLUSION The Ray tracing technique is still a immature technique for game industry. To bring it into practice, lots of optimisation need to be done. In further work, this article will implement the actual renderer and doing some optimisation. REFERENCES [1] Cabral, B., Olano, M., & Nemec, P. (1999). Reflection space image based rendering. (pp.165-170). [2] Schulz, N. . The rendering technology of ryse. Crytek Com. [3] Glassner, A. S. (1989). An introduction to ray tracing. Morgan Kaufmann Pub. . [4] Purcell, T., Buck, I., Mark, W., & Hanrahan, P. (2002). Ray tracing on programmable graphics hardware. ACM Transactions On Graphics, 21(3). doi: 10.1145/566654.566640 [5] Chiarotti, G. (1973). Optical properties of solids. Optica Acta International Journal of Optics, 14(4), 436-436. [6] Phong, B. (1975). Illumination for computer generated pictures. Communications Of The ACM, 18(6), 311- 317. doi: 10.1145/360825.360839 1 2 3 4 5 6 7 8 </p>
</div>
</body>
</html>
